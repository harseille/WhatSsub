{"version":3,"names":["cliOptions","babelOptions","buildResult","fileResults","mapSections","code","offset","hasRawMap","result","map","push","line","column","version","names","sources","mappings","countNewlines","AnyMap","file","sourceMapTarget","path","basename","outFile","sections","sourceRoot","sourceMaps","convertSourceMap","fromObject","encodedMap","toComment","count","index","indexOf","output","dirname","recursive","outputMap","undefined","util","hasDataSourcemap","mapLoc","addSourceMappingUrl","fs","writeFileSync","JSON","stringify","process","stdout","write","readStdin","Promise","resolve","reject","stdin","setEncoding","on","chunk","read","res","transformRepl","filename","sourceFileName","walk","filenames","_filenames","forEach","existsSync","stat","statSync","isDirectory","readdirForCompilable","includeDotfiles","extensions","join","results","all","sourceFilename","relative","slash","compile","err","watch","console","error","files","watcher","enable","enableGlobbing","skipInitialBuild","startWatcher","onFilesChange","changes","event","cause","actionableChange","some","isCompilableExtension","includes","verbose","log","catch","length"],"sources":["../../src/babel/file.ts"],"sourcesContent":["import convertSourceMap from \"convert-source-map\";\nimport { AnyMap, encodedMap } from \"@jridgewell/trace-mapping\";\nimport slash from \"slash\";\nimport path from \"path\";\nimport fs from \"fs\";\n\nimport * as util from \"./util\";\nimport type { CmdOptions } from \"./options\";\nimport * as watcher from \"./watcher\";\n\nimport type {\n  SectionedSourceMap,\n  SourceMapInput,\n  TraceMap,\n} from \"@jridgewell/trace-mapping\";\nimport type { FileResult } from \"@babel/core\";\n\ntype CompilationOutput = {\n  code: string;\n  map: SourceMapInput;\n  hasRawMap: boolean;\n};\n\nexport default async function ({\n  cliOptions,\n  babelOptions,\n}: CmdOptions): Promise<void> {\n  function buildResult(fileResults: Array<FileResult>): CompilationOutput {\n    const mapSections: SectionedSourceMap[\"sections\"] = [];\n\n    let code = \"\";\n    let offset = 0;\n\n    let hasRawMap = false;\n\n    for (const result of fileResults) {\n      if (!result) continue;\n\n      hasRawMap = !!result.map;\n\n      mapSections.push({\n        offset: { line: offset, column: 0 },\n        map: result.map || {\n          version: 3,\n          names: [],\n          sources: [],\n          mappings: [],\n        },\n      });\n\n      code += result.code + \"\\n\";\n      offset += countNewlines(result.code) + 1;\n    }\n\n    const map = new AnyMap({\n      version: 3,\n      file:\n        cliOptions.sourceMapTarget ||\n        path.basename(cliOptions.outFile || \"\") ||\n        \"stdout\",\n      sections: mapSections,\n    });\n    // For some reason, the spec doesn't allow sourceRoot when constructing a\n    // sectioned sourcemap. But AllMap returns a regular sourcemap, we can\n    // freely add to with a sourceRoot.\n    map.sourceRoot = babelOptions.sourceRoot;\n\n    // add the inline sourcemap comment if we've either explicitly asked for inline source\n    // maps, or we've requested them without any output file\n    if (\n      babelOptions.sourceMaps === \"inline\" ||\n      (!cliOptions.outFile && babelOptions.sourceMaps)\n    ) {\n      code += \"\\n\" + convertSourceMap.fromObject(encodedMap(map)).toComment();\n    }\n\n    return {\n      map: map,\n      code: code,\n      hasRawMap: hasRawMap,\n    };\n  }\n\n  function countNewlines(code: string): number {\n    let count = 0;\n    let index = -1;\n    while ((index = code.indexOf(\"\\n\", index + 1)) !== -1) {\n      count++;\n    }\n    return count;\n  }\n\n  function output(fileResults: Array<FileResult>): void {\n    const result = buildResult(fileResults);\n\n    if (cliOptions.outFile) {\n      fs.mkdirSync(path.dirname(cliOptions.outFile), { recursive: true });\n\n      let outputMap: \"both\" | \"external\" | false = false;\n      if (babelOptions.sourceMaps && babelOptions.sourceMaps !== \"inline\") {\n        outputMap = \"external\";\n      } else if (babelOptions.sourceMaps == undefined && result.hasRawMap) {\n        outputMap = util.hasDataSourcemap(result.code) ? \"external\" : \"both\";\n      }\n\n      if (outputMap) {\n        const mapLoc = cliOptions.outFile + \".map\";\n        if (outputMap === \"external\") {\n          result.code = util.addSourceMappingUrl(result.code, mapLoc);\n        }\n        fs.writeFileSync(\n          mapLoc,\n          JSON.stringify(encodedMap(result.map as TraceMap)),\n        );\n      }\n\n      fs.writeFileSync(cliOptions.outFile, result.code);\n    } else {\n      process.stdout.write(result.code + \"\\n\");\n    }\n  }\n\n  function readStdin(): Promise<string> {\n    return new Promise((resolve, reject): void => {\n      let code = \"\";\n\n      process.stdin.setEncoding(\"utf8\");\n\n      process.stdin.on(\"readable\", function () {\n        const chunk = process.stdin.read();\n        if (chunk !== null) code += chunk;\n      });\n\n      process.stdin.on(\"end\", function () {\n        resolve(code);\n      });\n      process.stdin.on(\"error\", reject);\n    });\n  }\n\n  async function stdin(): Promise<void> {\n    const code = await readStdin();\n\n    const res = await util.transformRepl(cliOptions.filename, code, {\n      ...babelOptions,\n      sourceFileName: \"stdin\",\n    });\n\n    output([res]);\n  }\n\n  async function walk(filenames: Array<string>): Promise<void> {\n    const _filenames: string[] = [];\n\n    filenames.forEach(function (filename) {\n      if (!fs.existsSync(filename)) return;\n\n      const stat = fs.statSync(filename);\n      if (stat.isDirectory()) {\n        const dirname = filename;\n\n        util\n          .readdirForCompilable(\n            filename,\n            cliOptions.includeDotfiles,\n            cliOptions.extensions,\n          )\n          .forEach(function (filename) {\n            _filenames.push(path.join(dirname, filename));\n          });\n      } else {\n        _filenames.push(filename);\n      }\n    });\n\n    const results = await Promise.all(\n      _filenames.map(async function (filename: string): Promise<any> {\n        let sourceFilename = filename;\n        if (cliOptions.outFile) {\n          sourceFilename = path.relative(\n            path.dirname(cliOptions.outFile),\n            sourceFilename,\n          );\n        }\n        sourceFilename = slash(sourceFilename);\n\n        try {\n          return await util.compile(filename, {\n            ...babelOptions,\n            sourceFileName: sourceFilename,\n            // Since we're compiling everything to be merged together,\n            // \"inline\" applies to the final output file, but not to the individual\n            // files being concatenated.\n            sourceMaps:\n              babelOptions.sourceMaps === \"inline\"\n                ? true\n                : babelOptions.sourceMaps,\n          });\n        } catch (err) {\n          if (!cliOptions.watch) {\n            throw err;\n          }\n\n          console.error(err);\n          return null;\n        }\n      }),\n    );\n\n    output(results);\n  }\n\n  async function files(filenames: Array<string>): Promise<void> {\n    if (cliOptions.watch) {\n      watcher.enable({ enableGlobbing: false });\n    }\n\n    if (!cliOptions.skipInitialBuild) {\n      await walk(filenames);\n    }\n\n    if (cliOptions.watch) {\n      filenames.forEach(watcher.watch);\n\n      watcher.startWatcher();\n\n      watcher.onFilesChange((changes, event, cause) => {\n        const actionableChange = changes.some(\n          filename =>\n            util.isCompilableExtension(filename, cliOptions.extensions) ||\n            filenames.includes(filename),\n        );\n        if (!actionableChange) return;\n\n        if (cliOptions.verbose) {\n          console.log(`${event} ${cause}`);\n        }\n\n        walk(filenames).catch(err => {\n          console.error(err);\n        });\n      });\n    }\n  }\n\n  if (cliOptions.filenames.length) {\n    await files(cliOptions.filenames);\n  } else {\n    await stdin();\n  }\n}\n"],"mappings":"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"}