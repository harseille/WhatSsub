{"version":3,"names":["fileToDeps","Map","depToFiles","isWatchMode","watcher","watchQueue","Set","hasStarted","enable","enableGlobbing","FSWatcher","requireChokidar","options","disableGlobbing","persistent","ignoreInitial","awaitWriteFinish","stabilityThreshold","pollInterval","on","unwatchFile","startWatcher","dep","add","clear","console","log","watch","filename","Error","path","resolve","onFilesChange","callback","event","absoluteFile","get","updateExternalDependencies","dependencies","absFilename","absDependencies","Array","from","deps","has","removeFileDependency","set","delete","size","unwatch","parseInt","process","versions","node","require","err","error"],"sources":["../../src/babel/watcher.ts"],"sourcesContent":["import { createRequire } from \"module\";\nimport path from \"path\";\nimport type { WatchOptions, FSWatcher } from \"chokidar\";\n\nconst fileToDeps = new Map<string, Set<string>>();\nconst depToFiles = new Map<string, Set<string>>();\n\nlet isWatchMode = false;\nlet watcher: FSWatcher;\nconst watchQueue = new Set<string>();\nlet hasStarted = false;\n\nexport function enable({ enableGlobbing }: { enableGlobbing: boolean }) {\n  isWatchMode = true;\n\n  const { FSWatcher } = requireChokidar();\n\n  const options: WatchOptions = {\n    disableGlobbing: !enableGlobbing,\n    persistent: true,\n    ignoreInitial: true,\n    awaitWriteFinish: {\n      stabilityThreshold: 50,\n      pollInterval: 10,\n    },\n  };\n  watcher = new FSWatcher(options);\n\n  watcher.on(\"unlink\", unwatchFile);\n}\n\nexport function startWatcher() {\n  hasStarted = true;\n\n  for (const dep of watchQueue) {\n    watcher.add(dep);\n  }\n  watchQueue.clear();\n\n  watcher.on(\"ready\", () => {\n    console.log(\"The watcher is ready.\");\n  });\n}\n\nexport function watch(filename: string): void {\n  if (!isWatchMode) {\n    throw new Error(\n      \"Internal Babel error: .watch called when not in watch mode.\",\n    );\n  }\n\n  if (!hasStarted) {\n    watchQueue.add(path.resolve(filename));\n  } else {\n    watcher.add(path.resolve(filename));\n  }\n}\n\n/**\n * Call @param callback whenever a dependency (source file)/\n * external dependency (non-source file) changes.\n *\n * Handles mapping external dependencies to their corresponding\n * dependencies.\n */\nexport function onFilesChange(\n  callback: (filenames: string[], event: string, cause: string) => void,\n): void {\n  if (!isWatchMode) {\n    throw new Error(\n      \"Internal Babel error: .onFilesChange called when not in watch mode.\",\n    );\n  }\n\n  watcher.on(\"all\", (event, filename) => {\n    if (event !== \"change\" && event !== \"add\") return;\n\n    const absoluteFile = path.resolve(filename);\n    callback(\n      [absoluteFile, ...(depToFiles.get(absoluteFile) ?? [])],\n      event,\n      absoluteFile,\n    );\n  });\n}\n\nexport function updateExternalDependencies(\n  filename: string,\n  dependencies: Set<string>,\n) {\n  if (!isWatchMode) return;\n\n  // Use absolute paths\n  const absFilename = path.resolve(filename);\n  const absDependencies = new Set(\n    Array.from(dependencies, dep => path.resolve(dep)),\n  );\n\n  const deps = fileToDeps.get(absFilename);\n  if (deps) {\n    for (const dep of deps) {\n      if (!absDependencies.has(dep)) {\n        removeFileDependency(absFilename, dep);\n      }\n    }\n  }\n  for (const dep of absDependencies) {\n    let deps = depToFiles.get(dep);\n    if (!deps) {\n      depToFiles.set(dep, (deps = new Set()));\n\n      if (!hasStarted) {\n        watchQueue.add(dep);\n      } else {\n        watcher.add(dep);\n      }\n    }\n\n    deps.add(absFilename);\n  }\n\n  fileToDeps.set(absFilename, absDependencies);\n}\n\nfunction removeFileDependency(filename: string, dep: string) {\n  const deps = depToFiles.get(dep) as Set<string>;\n  deps.delete(filename);\n\n  if (deps.size === 0) {\n    depToFiles.delete(dep);\n\n    if (!hasStarted) {\n      watchQueue.delete(dep);\n    } else {\n      watcher.unwatch(dep);\n    }\n  }\n}\n\nfunction unwatchFile(filename: string) {\n  const deps = fileToDeps.get(filename);\n  if (!deps) return;\n\n  for (const dep of deps) {\n    removeFileDependency(filename, dep);\n  }\n  fileToDeps.delete(filename);\n}\n\nfunction requireChokidar(): any {\n  const require = createRequire(import.meta.url);\n\n  try {\n    return process.env.BABEL_8_BREAKING\n      ? require(\"chokidar\")\n      : parseInt(process.versions.node) >= 8\n      ? require(\"chokidar\")\n      : require(\"@nicolo-ribaudo/chokidar-2\");\n  } catch (err) {\n    console.error(\n      \"The optional dependency chokidar failed to install and is required for \" +\n        \"--watch. Chokidar is likely not supported on your platform.\",\n    );\n    throw err;\n  }\n}\n"],"mappings":"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"}